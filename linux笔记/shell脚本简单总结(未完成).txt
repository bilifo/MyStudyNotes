一般shell脚本以.sh为后缀,但实际上,无论什么格式的文件,都可以运行,只要包含可识别的shell命令
由于linux很多文件没有后缀,对于某些特定打开方式的文件类型,要判断文件类型,可以用读取文件头来识别

运行脚本,不能直接test.sh,而是要./test.sh,如果不加的话，linux 默认会从PATH 里去找该 test.sh。

注释:
	#符号
	注:每个shell文件开头的#!/bin/sh或#!/bin/bash,表示运行此脚本的解释器路经
调试:
	使用"sh -x XXX.sh"来进行简单调试

通配符:
	*符号 或@符号,在数组中 var[*]或 var[@]表示获取数组中的所有元素,数组循环常常写成这样: for c in c_nums[@]
包含:
	.符号	或source eg:. filename 或 source filename

变量:字母和下划线
	声明时无需申明类型,和python一样.在使用时,需要加上$符号,可选的{}可以用于定义定量边界,如,echo "${var}1 is true"
	使用 readonly 命令可以将变量定义为只读变量.如,readonly var
	使用 unset 命令可以删除变量,变量被删除后不能再次使用.如,unset var
	变量声明,可以使用,$(),${},$$,一个意思.$()中可以是全局变量,也可以是命令,如: cur-dir := $(shell pwd)
	export 环境变量

传入参数:
	$# 将告诉您脚本传递的输入参数的数量。eg:$# -eq 0
	$1 $2 ...$n 代表运行时传入的参数
	最好使用双引号将$n包住(也可以使用花括号{$n}),这样能避免"unexpected operator/operand"警告

:= , = ,+=,?=的区别:
	:=	重新复制,不影响该符号前的变量引用
	=	全局赋值,影响全部引用
	?=	如果变量未定义,那么就赋值定义,如果定义过,就无作用
	-z	检测字符串长度是否为0，为0返回 true。eg:[ -z "$a" ] 返回 false。
	-n	检测字符串长度是否不为 0，不为 0 返回 true。eg:[ -n "$a" ] 返回 true。

判断:
	不是通常见到的()括号,而是使用[]中括号.且中括号内两边都要用空格间隔,哪怕错一个,程序就运行不起来
	if [ "$1" == "start" ]
	   then
	       if [ "$2" == "fun1" ]; then
	          ...
	       if
	        ....
	elif[ "$1" == "stop"]
                   then
	        ....
	 fi
	


字符串:
	单双引号的区别:
		单引号,单引号字符串中的变量是无效的,不能出现转义字符,且不能在内部再出现单引号
		双引号,解决单引号的问题
	$1 或 $2:
		表示使用该函数时传入的第一个参数和第二个参数,$n以此类推.如命令"source  test.sh start",脚本内部使用if[$1=="start"]来判断是否第一个参数是start
	获取字符串长度:
		${#var}
		或	`expr?length?$var`	(注意,这不是单引号,而是`)
	提取子字符串:
		${var:1} 				取从1开始的剩下所有字符内容
		${var:1:4} 				取从1开始的4个字符内容
		或	`expr?substr?$var?1?4`??
	字符串的拼接:
		${var1}${var2}

	查找子字符串:
		字符在串中的下标:
			`expr?index?$str?"b"`??
	删除子字符串:
		test="111aaa222"
		${var#需要删除的子字符串}		从 左侧 开头开始删除 最短 匹配的子字符串	如:${test#1*a}  结果:aa222
		${var##需要删除的子字符串}		从 左侧 开头开始删除 最长 匹配的子字符串	如:${test##1*a}  结果:222
		${var%需要删除的子字符串}		从 右侧 结尾开始删除 最短 匹配的子字符串	如:${test%a*2}  结果:111aa
		${var%%需要删除的子字符串}		从 右侧 结尾开始删除 最长 匹配的子字符串	如:${test%%a*2}  结果:111
	替换子字符串:
		${变量/查找需要替换的/替换值}		如:${test/o/i} #替换test变量中第一个'o'为'i'
		${变量//查找需要替换的/替换值}		如:${test//o/i} #替换test变量中所有'o'为'i'
		${变量/#查找需要替换的/替换值}		如:${test/#ooo/ii} #替换test变量中开头的'ooo'为'ii'
		${变量/%查找需要替换的/替换值}		如:${test/%ooo/ii} #替换test变量中结尾的'ooo'为'ii'
	添加子字符串:
		${var:0:添加位置}${需要插入的子串}${var:添加位置}	用拼接的方式实现

shell脚本中的 2>&1 > /dev/null 表示什么:
	默认情况下，总是有三个文件处于打开状态，标准输入(键盘输入)、标准输出（输出到屏幕）、标准错误（也是输出到屏幕），它们分别对应的文件描述符是0，1，2.
	/dev/null ：代表空设备文件,这是一个黑洞,输入到这个地方的东西都消失了
	>:代表重定向
	>/dev/null :由于系统默认stout标准输出默认值是1,所以">/dev/null"等同于"1>/dev/null"
	&  ：表示等同于的意思，2>&1，表示2的输出重定向等同于1.
		
	>/dev/null 2>&1: 等同1>/dev/null 2>&1,即标准输出和标准错误都输出到/dev/null,不在终端显示
	2>&1 > /dev/nul:标准错误复制到标准输出中,1>/dev/null 标准输出到dev/nul中,但屏幕依然会输出标准错误

	为什么需要>&这种写法?cmd >a 2>a 和 cmd >a 2>&1 为什么不同:
		cmd >a 2>a ：stdout和stderr都直接送往文件 a ，a文件会被打开两遍，由此导致stdout和stderr互相覆盖。
		cmd >a 2>&1 ：stdout直接送往文件a ，stderr是继承了FD1的管道之后，再被送往文件a 。a文件只被打开一遍，就是FD1将其打开。
		



坑点:
	1.在window下编辑的shell脚本,由于window会在文件信息前加上window标记,导致该脚本在Linux上运行出现些莫名其妙的问题
	解决方法:用notepad++编写完后,选"编辑"--->"文档格式转换"--->"转换成UNIX"
