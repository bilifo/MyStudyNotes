一般shell脚本以.sh为后缀,但实际上,无论什么格式的文件,都可以运行,只要包含可识别的shell命令
由于linux很多文件没有后缀,对于某些特定打开方式的文件类型,要判断文件类型,可以用读取文件头来识别

运行脚本,不能直接test.sh,而是要./test.sh,如果不加的话，linux 默认会从PATH 里去找该 test.sh。

注释:
	#符号
	注:每个shell文件开头的#!/bin/sh或#!/bin/bash,表示运行此脚本的解释器路经

通配符:
	*符号

变量:字母和下划线
	声明时无需申明类型,和python一样.在使用时,需要加上$符号,可选的{}可以用于定义定量边界,如,echo "${var}1 is true"
	使用 readonly 命令可以将变量定义为只读变量.如,readonly var
	使用 unset 命令可以删除变量,变量被删除后不能再次使用.如,unset var
	
字符串:
	单双引号的区别:
		单引号,单引号字符串中的变量是无效的,不能出现转义字符,且不能在内部再出现单引号
		双引号,解决单引号的问题
	获取字符串长度:
		${#var}
		或	`expr?length?$var`	(注意,这不是单引号,而是`)
	提取子字符串:
		${var:1} 				取从1开始的剩下所有字符内容
		${var:1:4} 				取从1开始的4个字符内容
		或	`expr?substr?$var?1?4`??
	字符串的拼接:
		${var1}${var2}
	
	查找子字符串:
		字符在串中的下标:
			`expr?index?$str?"b"`??
	删除子字符串:
		test="111aaa222"
		${var#需要删除的子字符串}		从 左侧 开头开始删除 最短 匹配的子字符串	如:${test#1*a}  结果:aa222
		${var##需要删除的子字符串}		从 左侧 开头开始删除 最长 匹配的子字符串	如:${test##1*a}  结果:222
		${var%需要删除的子字符串}		从 右侧 结尾开始删除 最短 匹配的子字符串	如:${test%a*2}  结果:111aa
		${var%%需要删除的子字符串}		从 右侧 结尾开始删除 最长 匹配的子字符串	如:${test%%a*2}  结果:111
	替换子字符串:
		${变量/查找需要替换的/替换值}		如:${test/o/i} #替换test变量中第一个'o'为'i'
		${变量//查找需要替换的/替换值}		如:${test//o/i} #替换test变量中所有'o'为'i'
		${变量/#查找需要替换的/替换值}		如:${test/#ooo/ii} #替换test变量中开头的'ooo'为'ii'	
		${变量/%查找需要替换的/替换值}		如:${test/%ooo/ii} #替换test变量中结尾的'ooo'为'ii'
	添加子字符串:
		${var:0:添加位置}${需要插入的子串}${var:添加位置}	用拼接的方式实现
		
		
		
	
	
坑点:
	1.在window下编辑的shell脚本,由于window会在文件信息前加上window标记,导致该脚本在Linux上运行出现些莫名其妙的问题
	解决方法:用notepad++编写完后,选"编辑"--->"文档格式转换"--->"转换成UNIX"
