任何合法的c程序都是合法的c++程序,即c能编译运行,那放到c++中就一定能运行

编译运行c++文件:
使用g++ hello.cpp 后会默认生成 a.out
或使用g++ hello.cpp -o a
输出文件,再./a.out运行程序

一个简单的c++ hello_world:
#include <iostream>
using namespace std;
int main(){
   cout << "Hello World"; // 输出 Hello World
   return 0;
}

导包:#include <包名>			区别于java:implement com.XX.XXX


基本类型:bool				区别于java:boolean
基本类型:wchar_t				区别于java:
常量:const					区别于java:final

数字后加U/u或L/l表示该数字是无符号整数unsigned,长整数long
声明时变量前加"基本类型 &",表示引用只是另一个变量的别称,实际是同一个东西(主要用于函数的形参和函数的返回类型)
调用时变量前加 & 返回该变量的地址


声明时变量前加"基本类型 *",该指针变量表示另一个变量的地址	
声明时变量前加"基本类型 **",该二级指针变量表示另一个一级"基本类型 *"型的指针变量地址
调用时变量前加"*",表示取该地址的内容	
特别注意:
	在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。并且在使用指针时,一定要避免出现使用未赋值的空指针


static	文件内全局
extern	文件外全局
thread_local		声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。

字符串操作:
strcpy(s1, s2);复制字符串 s2 到字符串 s1。
strcat(s1, s2);连接字符串 s2 到字符串 s1 的末尾。
strlen(s1);返回字符串 s1 的长度
strcmp(s1, s2);如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回值小于 0；如果 s1>s2 则返回值大于 0。
strchr(s1, ch);返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。
strstr(s1, s2);返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。

时间和日期:include <ctime>

标准输入输出:
include <iostream>
	cout << "输出内容:" << str <<endl;//endl 用于在行末添加一个换行符
	cin >> 变量1 >> 变量2;//将输了给变量,回车结束
	cerr << "错误信息:" << str <<endl;
	clog << "日志信息:" << str <<endl;

结构体:
struct struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下

struct type_name {
member_type1 member_name1;
member_type2 member_name2;
member_type3 member_name3;
.
.
} object_names;
type_name 是结构体类型的名称，member_type1 member_name1 是标准的变量定义，比如 int i; 或者 float f;在结构定义的末尾，最后一个分号之前，您可以指定一个或多个结构变量，这是可选的。它是类的雏形
用"."来访问结构体成员.
函数的形参:void printBook( struct Books book );
指向结构的指针:struct Books *struct_pointer;



类和结构体的区别:
类的成员默认是private的,而结构体是public.
