
Numpy是Python的一个很重要的第三方库，很多其他科学计算的第三方库都是以Numpy为基础建立的。
甚至使用它直接替代了python原本的数组

导入:

	import numpy
	import numpy as np #导入,并别名为np

|创建数据方法||
|-|-|
|np=Numpy.array(数组1,数组2,...)          |根据多个参数数组,创建一个多维矩阵|
|np=Numpy.arange(起,终,步长)              |创建一维数组,不包含终点,步长默认为1|
|np=Numpy.linspace(起,终,个数)            |创建指定个数的等差数组,包括终点,个数默认为50|
|np=Numpy.logspace(初幂,终幂,个数,base=底数) |创建指定个数的等比数组,默认底数是10|
|np=Numpy.zeros((2,2))                   |创建一个2*2大小的,所有元素是0的矩阵|
|np=Numpy.ones((3,2,2),dtype=float)      |创建一个3*2*2大小的,所有元素是1的float矩阵|
|np=numpy.full((4,2,4), 7)               |创建一个4*2*4大小的,所有元素是7的矩阵|
|np=Numpy.eye(12)                        |创建一个12*12大小的单位矩阵|
|np=numpy.random.random((3,2))           |创建一个3*2大小的随机矩阵|
|np=numpy.formstring(字符串,dtype=类型)   |把字符串转换成指定类型的一维数组|
|np=numpy.fromfunction(方法,(矩阵大小))   |把方法函数的返回值们,建立一个指定大小的矩阵|
  
|基础运算||
|-|-|
|a = numpy.abs(-1)                       | 绝对值，1|
|b = numpy.sin(numpy.pi/2)               | sin函数，1.0|
|c = numpy.arctanh(0.462118)             | tanh逆函数，0.50000107157840523|
|d = numpy.exp(3)                        | e为底的指数函数，20.085536923187668|
|f = numpy.power(2, 3)                   | 2的3次方，8|
|g = numpy.dot([1, 2], [3, 4])           | 点积，1*3+2*4=11|
|h = numpy.sqrt(25)                      | 开方，5|
|l = numpy.sum([1, 2, 3, 4])             | 求和，10|
|m = numpy.mean([4, 5, 6, 7])            | 平均值，5.5|
|p = numpy.std([1, 2, 3, 2, 1, 3, 2, 0]) | 标准差，0.96824583655185426|

|检查方法||
|-|-|
|np.shape                                |获得矩阵的大小,注:此处的-1表示自动计算长度|
|np.reshape(矩阵大小)                     |在不改变原矩阵数据的情况下,新建一个指定大小的矩阵,元素一样.reshape(-1),将多维转为一维|
|np.size                                 |元素总个数|
|np.max()                                |矩阵中最大元素|
|np.min()                                |矩阵中最小元素|
|np.flatten()                            |把多维矩阵变为一维数组|
|np.ravel(多维矩阵)                       |把多维矩阵变为一维数组|
|numpy.split(numpy.arange(9), 3)==[array([0, 1, 2]), array([3, 4, 5]), array([6, 7, 8])]|拆分矩阵|

取矩阵元素:
示例矩阵:

	A([ [ [ 0,1,2,3],[ 4,5,6,7],[ 8,9, 10, 11] ],[ [12, 13, 14, 15],[16, 17, 18, 19],[20, 21, 22, 23] ] ])

A[1][1][1]==17       #表明还是以下标0开始  
A[:, 2, :]==[[ 8,9, 10, 11],[20, 21, 22, 23]]#用:表示当前维度上所有下标  
A[..., 1]==[[ 1,5,9], [13, 17, 21]]#用...表示没有明确指出的维度  
用法详解:注意下面的并不一定有值,只是演示:

	a[5] # 用整数作为下标可以获取数组中的某个元素  
	a[3:5] # 用范围作为下标获取数组的一个切片，包括a[3]不包括a[5]  
	a[:5] # 省略开始下标，表示从a[0]开始  
	a[:-1] # 下标可以使用负数，表示从数组后往前数  
	a[2:4] = 100,101 # 下标还可以用来修改元素的值  
	a[1:-1:2] # 范围中的第三个参数表示步长，2表示隔一个元素取一个元素  
	a[::-1] # 省略范围的开始下标和结束下标，步长为-1，整个数组头尾颠倒  
	a[5:1:-2] # 步长为负数时，开始下标必须大于结束下标,即从5数到1  

矩阵变换:
示例矩阵:  

	a=numpy.array([[1,2,3],[4,5,6],[7,8,9]])
	b=numpy.array(range(30)).reshape(2, 3, 5)

a.transpose()#a的转置矩阵,结果a=[[1 4 7],[2 5 8],[3 6 9]]
b.transpose((1, 0, 2))#b 位置变换
因为数组b的shape(矩阵大小)为(2,3,5)，是一个三维数组，那么这个元组对应的索引为：(0,1,2)，也就是b.shape的下标：(2[0], 3[1], 5[2])， []中对应的是shape元组的索引。那么，现在，通过b = b.transpose(1, 0, 2)，那么b.shape就变成(3， 2， 5)，这就是说transpose就是改变高维数组的形状，形状改变了，那么里面的元素自然也要重新排列

	#a 沿水平轴进行上下翻转
	numpy.flipud(a)	a=[[7,8,9],[4,5,6],[1,2,3]]

	#a 沿纵轴进行左右翻转
	numpy.fliplr(a)	a=[[3,6,9],[2,5,8],[1,4,7]]

	#a 逆时针旋转90度，第二个参数是旋转次数
	numpy.rot90(矩阵a,次数1次)	a=[[3 6 9],[2 5 8],[1 4 7]]

	#a 按照一维数组进行滚动
	numpy.roll(矩阵a,滚动位移次数1次)	a=[[9 1 2], [3 4 5], [6 7 8]]


矩阵运算:
示例矩阵:

	a = numpy.array([[1, 2, 3],[4, 5, 6]])
	b = numpy.array([[1, 2, 3],[1, 2, 3]])

#维度一样的array，对位计算
	#array([[2, 4, 6], [5, 7, 9]])
	a + b

	#array([[0, 0, 0], [3, 3, 3]])
	a - b

	#array([[ 1,4,9], [ 4, 10, 18]])
	a * b

	#array([[1, 1, 1], [4, 2, 2]])
	a / b

	#array([[ 1,4,9], [16, 25, 36]])
	a ** 2

	#array([[1, 4,27], [4,25, 216]])
	a ** b

示例矩阵:

	c = numpy.array([[1, 2, 3],[4, 5, 6],[7, 8, 9],[10, 11, 12]])
	d = numpy.array([2, 2, 2])

#广播机制让计算的表达式保持简洁  

	#d和c的每一行分别进行运算
	#array([[ 3,4,5],[ 6,7,8],[ 9, 10, 11], [12, 13, 14]])
	c + d

	#array([[ 2,4,6],[ 8, 10, 12],[14, 16, 18],[20, 22, 24]])
	c * d

	#1和c的每个元素分别进行运算
	#array([[ 0,1,2],[ 3,4,5],[ 6,7,8],[ 9, 10, 11]])
	c - 1

|线性代数相关:||
|-|-|
|Numpy.trace(矩阵)		|求矩阵的迹|
|Numpy.linalg.det(矩阵)		|求矩阵的行列式值|
|Numpy.linalg.matrix_rank(矩阵)	|求矩阵的秩|  

随机模块:  

	random.seed(int)	设置随机种子(真随机数),参数是随机数上限.
	#随机种子,即是由不同的硬件和系统组成的平台,运行生成随机数,由于种子的存在,都会出现一样的随机数

	Numpy.random.rand(矩阵大小)	生成一个各元素在[0,1)之间的矩阵
	Numpy.random.random(矩阵大小)	生成一个各元素在[0,1)之间的矩阵
	Numpy.random.random()	生成一个一个各元素在[0,1)之间的随机数
	Numpy.random.randint()	生成整形随机数
	Numpy.random.normal(size=(5,2))	生成一个2*5的标准正态分布样本
	Numpy.random.binomial(n=5,p=0.5,size=5)	生成5个,n=5,p=0.5的二项分布样本
	Numpy.random.choice(矩阵a,采样数7,replace=False)	从a矩阵中采样7个,不放回
	Numpy.random.permutation(矩阵a)	对a进行乱序排列,并返回新矩阵
	Numpy.random.shuffle(矩阵a)	对a进行in-place乱序
	numpy.random.uniform()  

排序:

	numpy.sort(矩阵数组)

搜索:

	numpy.where(矩阵数组 == 数组中某个值) #在数组中搜索（检索）某个值，然后返回获得匹配的索引。
	numpy.searchsorted(矩阵数组,数组中某个值,[side='right']) #快速的二分查找,使用有前置条件,即数组必须是经过排序的,side='right'是可选项查找方向,也可以多值查询eg:np.searchsorted(arr, [2, 4, 6])

数组过滤:  
在 NumPy 中，我们使用布尔索引列表来过滤数组。布尔索引列表是与数组中的索引相对应的布尔值列表。
如果索引处的值为 True，则该元素包含在过滤后的数组中；如果索引处的值为 False，则该元素将从过滤后的数组中排除。
即,对有数据的数组添加一个大小相同的只含有Ture和False的数组,作为判断过滤的依据

	import numpy as np
	arr = np.array([61, 62, 63, 64, 65])
	x = [True, False, True, False, True]
	newarr = arr[x] #关键一步,将true和false数组赋给arr,没想到还能这么玩吧,其实玩法还有很多,比如下面的注释
	# newarr = arr[1,2,3,4] #输出下标1,2,3,4的值
	# newarr = arr[arr > 62] #输出大于62的值
	print(newarr)


